# -*- coding: utf-8 -*-
"""xai_visualizer.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mkW0gudx8jJ5I5lBjZj9TCYT9WfzmabJ
"""

import tensorflow as tf
import numpy as np
import cv2 # OpenCV
import matplotlib.pyplot as plt
import argparse
import os

# --- Configuration ---
MODEL_PATH = 'models/global_model.h5'
IMG_SIZE = (224, 224)
OUTPUT_PATH = 'output/xai_visualization.png'
# --- End Configuration ---

def load_and_preprocess_image(image_path):
    """Loads and prepares a single image for the model."""
    img = tf.io.read_file(image_path)
    img = tf.image.decode_png(img, channels=3)
    img = tf.image.resize(img, IMG_SIZE)
    img = tf.keras.applications.resnet50.preprocess_input(img)
    img = np.expand_dims(img, axis=0)
    return img

def get_grad_cam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    """Generates the Grad-CAM heatmap."""

    # 1. Create a sub-model from model's input to the last conv layer
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer(last_conv_layer_name).output, model.output]
    )

    # 2. Get gradients of the top predicted class
    with tf.GradientTape() as tape:
        last_conv_layer_output, preds = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(preds[0])
        class_channel = preds[:, pred_index]

    grads = tape.gradient(class_channel, last_conv_layer_output)

    # 3. Get neuron importance weights (Global Average Pooling on grads)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    # 4. Compute weighted combination of feature maps
    last_conv_layer_output = last_conv_layer_output[0]
    heatmap = last_conv_layer_output @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)

    # 5. Apply ReLU and normalize
    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    return heatmap.numpy()

def overlay_heatmap(original_img_path, heatmap):
    """Overlays the heatmap on the original image."""
    img = cv2.imread(original_img_path)

    # Resize heatmap to match original image size
    heatmap = cv2.resize(heatmap, (img.shape[1], img.shape[0]))

    # Convert heatmap to 8-bit
    heatmap = np.uint8(255 * heatmap)

    # Apply colormap
    heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)

    # Superimpose the heatmap
    superimposed_img = heatmap * 0.4 + img
    superimposed_img = np.clip(superimposed_img, 0, 255).astype(np.uint8)

    return superimposed_img

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate Grad-CAM XAI visualization.")
    parser.add_argument('--image_path', type=str, required=True, help="Path to the sample image.")
    args = parser.parse_args()

    print(f"Loading model from {MODEL_PATH}...")
    model = tf.keras.models.load_model(MODEL_PATH)

    # Find the name of the last convolutional layer
    last_conv_layer_name = ""
    for layer in reversed(model.layers):
        if isinstance(layer, tf.keras.layers.Conv2D):
            last_conv_layer_name = layer.name
            break
    print(f"Found last conv layer: {last_conv_layer_name}")

    # 1. Preprocess image
    img_array = load_and_preprocess_image(args.image_path)

    # 2. Generate heatmap
    print("Generating Grad-CAM heatmap...")
    heatmap = get_grad_cam_heatmap(img_array, model, last_conv_layer_name)

    # 3. Overlay heatmap on original image
    print("Overlaying heatmap on original image...")
    superimposed_image = overlay_heatmap(args.image_path, heatmap)

    # 4. Save the final image
    os.makedirs(os.path.dirname(OUTPUT_PATH), exist_ok=True)
    cv2.imwrite(OUTPUT_PATH, superimposed_image)

    print(f"XAI visualization saved to {OUTPUT_PATH}")